import e from"path";import t from"icu-minify/compile";import{getFormatExtension as s,resolveCodec as o}from"./format/index.js";import{setNestedProperty as r}from"./utils.js";let a=null;const n=new Map;function i(i){const c=this.getOptions(),l=this.async(),f=s(c.messages.format);(async function(e,t){return a||(a=await o(e.messages.format,t)),a})(c,this.rootContext).then((s=>{const o=e.basename(this.resourcePath,f);let a;if(c.messages.precompile){const e=function(e,s){const o={},a=new Set(s.keys());for(const n of e){a.delete(n.id);const e=n.message;if(Array.isArray(e))throw new Error(`Message at \`${n.id}\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/translations#arrays-of-messages`);if("object"==typeof e)throw new Error(`Message at \`${n.id}\` resolved to \`${typeof e}\`, but only strings are supported. Use a \`.\` to retrieve nested messages. See https://next-intl.dev/docs/usage/translations#structuring-messages`);const i=s.get(n.id);let c;i?.messageValue===e?c=i.compiledMessage:(c=t(e),s.set(n.id,{compiledMessage:c,messageValue:e})),r(o,n.id,c)}for(const e of a)s.delete(e);return o}(s.decode(i,{locale:o}),function(e){let t=n.get(e);return t||(t=new Map,n.set(e,t)),t}(this.resourcePath));a=JSON.stringify(e)}else a=s.toJSONString(i,{locale:o});const m=`export default JSON.parse(${JSON.stringify(a)});`;l(null,m)})).catch(l)}export{i as default};
